{"mappings":"4MAaSA,EAAsBC,EAAUC,mBAPXD,EAAUE,SAChCC,EAAMH,EAASI,QAAQC,WAAWH,EAAII,eACjC,IAAOC,UAAUP,EAASI,QAAQI,OAAOC,QAC9CC,IAAIR,EAAKC,GACRA,EAIAQ,CAAqBX,GAAiBC,EAd3B,MAEQW,MAAK,IAAKC,KAAKC,GAAMA,EAAEC,WAAW,MA6C3D,MACGC,EAKCC,YACOX,EAAQY,QACbC,WAAa,OACbC,YAAc,OACdC,iBAAmB,OAEnBC,cAAgBJ,OAChBK,QAAUjB,OACVkB,aAAY,WACRC,EAAI,EAAGA,EAACC,KAAQJ,cAAeG,GAAK,EAACC,KACvCF,aAAaC,GAAC,IAAQE,aAAarB,GAQvCsB,kCAESP,iBAQdJ,KAAKY,SAKGC,EAAeD,EAAc,GAAGvB,eAC7ByB,EAAI,EAAGA,EAAID,EAAcC,GAAK,EAAC,OAChCC,GAAUN,KAASN,YAAcW,GAACL,KAASH,gBACxCU,EAAU,EAAGA,EAAOP,KAAQJ,cAAeW,GAAW,EAACP,KACzDF,aAAaS,GAASD,GAAcH,EAAcI,GAASF,QAI/DX,aAAeU,OACXV,aAAWM,KAASH,UAAOG,KAC7BN,YAAc,QAIhBC,kBAAoBS,OAChBT,iBAAgBK,KAAQH,UAAOG,KACjCL,iBAAgBK,KAAQH,SASjCN,KAAKY,MAK2B,SAArBR,iBAAsB,aAIzBa,EAAoBL,EAAc,GAAGvB,eAGlCyB,EAAI,EAAGA,EAAIG,EAAmBH,GAAK,EAAC,OACrCI,GAAST,KAASP,WAAaY,GAACL,KAASH,gBACtCU,EAAU,EAAGA,EAAOP,KAAQJ,cAAeW,GAAW,EAC7DJ,EAAcI,GAASF,GAACL,KAASF,aAAaS,GAASE,QAItDhB,YAAce,OACVf,YAAUO,KAASH,UAAOG,KAC5BP,WAAa,QAGfE,kBAAoBa,OAChBb,iBAAmB,IAACK,KACtBL,iBAAmB,QAK1Be,EAAY,CACdC,IAAG,CACDC,aAAY,IAAQ,MAEtBC,uBAAsB,CACpBC,UAAS,IAAQ,KACjBC,eAAc,IAAQ,KACtBC,SAAQ,IAAQ,KAChBC,SAAQ,IAAQ,KAChBC,QAAO,IAAQ,KACfC,QAAO,IAAQ,OAImB,MAEhCC,EAAmB,YAEnBC,UAA4BC,kCACpBC,GACVC,6BACQC,EAAcC,QAAEC,EAAOC,WAAEA,GAAeL,EAAQM,sBACnDJ,eAAiBA,OACjBC,QAAUC,OACVC,WAAaA,OACbE,gBAAe,IAAOxC,EAAW8B,EAAkB,QACnDW,gCAIAzD,gBAAkB0D,YAAYC,YAAWjC,KAAMyB,eAAgBf,IAAepC,oBACxE4D,cAAalC,KAAM1B,SAAQ0B,KAAO0B,kCAI3BpD,EAAUoD,SACtBS,EAAQ7D,EAASI,QAAQ0D,YAEzBC,EAAYhE,EAAsBC,EAAUgE,KAAKC,UAAS,SAAGb,KAC7Dc,EAAWnE,EAAsBC,EAAQ,WAEzCmE,EAAMnE,EAASI,QAAQgE,0BAA0BL,EAAWG,eAC7DG,QAAUrE,EAASI,QAAQkE,qBAAqBH,EAAGzC,KAAO4B,YAC/DtD,EAASI,QAAQmE,KAAKJ,GAEtBnE,EAASI,QAAQoE,aAAaX,QACzBY,iBA3KYC,EAAY1E,SACzB2E,EAAU3E,EAASI,QAAQwE,OAAO,EAAIF,kBAO1CC,OANW,IAAOhD,aAAa3B,EAASI,QAAQI,OAAOC,QACpCoE,SAClBF,EAAU,EAAKA,EAAU,EAAKD,IAuKhBI,CAAYhC,EAAgBpB,KAAO1B,eAC7C+E,MAAQ/E,EAASI,QAAQwE,OAAO9B,QAKvC7B,QAAQ+D,EAAQC,OACTD,EAAO,GAAG1E,OAAM,OACZ,QAEH4E,EAAQF,EAAO,GACfG,EAASF,EAAQ,GAAG,WAErBzB,gBAAgB4B,KAAI,IAAKF,SAErB1B,gBAAgB5B,iBAAmBkB,EAAgB,MACrDU,gBAAgB6B,KAAI,MAAOZ,QAAQa,YAEnCC,YAAc,OACdvF,SAASI,QAAQoF,sBAAqB9D,KACpC2C,QAAO3C,KAAO+C,QAAQE,QAAS7B,SAGhC2C,EAAI/D,KAAQ1B,SAASI,QAAQsF,mBAAkBhE,KAC9C2C,QAAO3C,KAAOqD,MAAOjC,OAGf,IAAT2C,EAAW,OAGPE,EAFM,IAAOpF,UAASmB,KAAM1B,SAASI,QAAQI,OAAOC,QAErCkF,MAAKjE,KAAMqD,MAAKrD,KAAOqD,MAAQU,GAC9CG,GAvNEC,EAuNaF,EAAMlF,OAvNhB,QAAaqF,WAAWD,IAAMhF,KAAKC,GAAMiF,OAAOC,aAAalF,KAAImF,KAAI,UAwN3EC,KAAKC,YAAW,CACnBC,KAAI,gBACJR,KA1NE,IAAIC,SA+NZV,EAAOkB,SAASpE,YACLF,EAAI,EAAGA,EAAIE,EAAQ3B,OAAQyB,GAAK,EACvCE,EAAQF,GAAK,MAIV,GAIXuE,kBAAiB,uBAAyBvD","sources":["node_modules/@moxon6/quiet-js/dist/quiet.worklet.js"],"sourcesContent":["const NullTerminator = '\\0';\n\nconst encode = (str) => str.split('').map((x) => x.charCodeAt(0));\n\nconst decode = (buf) => [...new Uint8Array(buf)].map((x) => String.fromCharCode(x)).join('');\n\nfunction allocateArrayOnStack(instance, arr) {\n  const ret = instance.exports.stackAlloc(arr.length);\n  const HEAP8 = new Int8Array(instance.exports.memory.buffer);\n  HEAP8.set(arr, ret);\n  return ret;\n}\n\nfunction allocateStringOnStack(instance, string) {\n  return allocateArrayOnStack(instance, encode(string + NullTerminator));\n}\n\nfunction mallocArray(bufferSize, instance) {\n  const pointer = instance.exports.malloc(4 * bufferSize);\n  const HEAPF32 = new Float32Array(instance.exports.memory.buffer);\n  const view = HEAPF32.subarray(\n    (pointer / 4), (pointer / 4) + bufferSize,\n  );\n\n  return {\n    pointer,\n    view,\n  };\n}\n\n/* eslint-disable no-param-reassign */\n/* eslint-disable no-underscore-dangle */\n\n// Original Source: https://github.com/GoogleChromeLabs/web-audio-samples/blob/main/audio-worklet/design-pattern/lib/wasm-audio-helper.js\n\n/**\n * A JS FIFO implementation for the AudioWorklet. 3 assumptions for the\n * simpler operation:\n *  1. the push and the pull operation are done by 128 frames. (Web Audio\n *    API's render quantum size in the speficiation)\n *  2. the channel count of input/output cannot be changed dynamically.\n *    The AudioWorkletNode should be configured with the `.channelCount = k`\n *    (where k is the channel count you want) and\n *    `.channelCountMode = explicit`.\n *  3. This is for the single-thread operation. (obviously)\n *\n * @class\n */\nclass RingBuffer {\n  /**\n     * @constructor\n     * @param  {number} length Buffer length in frames.\n     * @param  {number} channelCount Buffer channel count.\n     */\n  constructor(length, channelCount) {\n    this._readIndex = 0;\n    this._writeIndex = 0;\n    this._framesAvailable = 0;\n\n    this._channelCount = channelCount;\n    this._length = length;\n    this._channelData = [];\n    for (let i = 0; i < this._channelCount; i += 1) {\n      this._channelData[i] = new Float32Array(length);\n    }\n  }\n\n  /**\n     * Getter for Available frames in buffer.\n     *\n     * @return {number} Available frames in buffer.\n     */\n  get framesAvailable() {\n    return this._framesAvailable;\n  }\n\n  /**\n     * Push a sequence of Float32Arrays to buffer.\n     *\n     * @param  {array} arraySequence A sequence of Float32Arrays.\n     */\n  push(arraySequence) {\n    // The channel count of arraySequence and the length of each channel must\n    // match with this buffer obejct.\n\n    // Transfer data from the |arraySequence| storage to the internal buffer.\n    const sourceLength = arraySequence[0].length;\n    for (let i = 0; i < sourceLength; i += 1) {\n      const writeIndex = (this._writeIndex + i) % this._length;\n      for (let channel = 0; channel < this._channelCount; channel += 1) {\n        this._channelData[channel][writeIndex] = arraySequence[channel][i];\n      }\n    }\n\n    this._writeIndex += sourceLength;\n    if (this._writeIndex >= this._length) {\n      this._writeIndex = 0;\n    }\n\n    // For excessive frames, the buffer will be overwritten.\n    this._framesAvailable += sourceLength;\n    if (this._framesAvailable > this._length) {\n      this._framesAvailable = this._length;\n    }\n  }\n\n  /**\n     * Pull data out of buffer and fill a given sequence of Float32Arrays.\n     *\n     * @param  {array} arraySequence An array of Float32Arrays.\n     */\n  pull(arraySequence) {\n    // The channel count of arraySequence and the length of each channel must\n    // match with this buffer obejct.\n\n    // If the FIFO is completely empty, do nothing.\n    if (this._framesAvailable === 0) {\n      return;\n    }\n\n    const destinationLength = arraySequence[0].length;\n\n    // Transfer data from the internal buffer to the |arraySequence| storage.\n    for (let i = 0; i < destinationLength; i += 1) {\n      const readIndex = (this._readIndex + i) % this._length;\n      for (let channel = 0; channel < this._channelCount; channel += 1) {\n        arraySequence[channel][i] = this._channelData[channel][readIndex];\n      }\n    }\n\n    this._readIndex += destinationLength;\n    if (this._readIndex >= this._length) {\n      this._readIndex = 0;\n    }\n\n    this._framesAvailable -= destinationLength;\n    if (this._framesAvailable < 0) {\n      this._framesAvailable = 0;\n    }\n  }\n} // class RingBuffer\n\nvar importObject = {\n  env: {\n    __sys_getpid: () => null,\n  },\n  wasi_snapshot_preview1: {\n    proc_exit: () => null,\n    clock_time_get: () => null,\n    fd_close: () => null,\n    fd_write: () => null,\n    fd_seek: () => null,\n    fd_read: () => null,\n  },\n};\n\n/* eslint-disable no-param-reassign */\n\nconst sampleBufferSize = 16384;\n\nclass WhiteNoiseProcessor extends AudioWorkletProcessor {\n  constructor(options) {\n    super();\n    const { quietWasmBytes, profile, sampleRate } = options.processorOptions;\n    this.quietWasmBytes = quietWasmBytes;\n    this.profile = profile;\n    this.sampleRate = sampleRate;\n    this.inputRingBuffer = new RingBuffer(sampleBufferSize, 1);\n    this.init();\n  }\n\n  async init() {\n    this.instance = (await WebAssembly.instantiate(this.quietWasmBytes, importObject)).instance;\n    await this.selectProfile(this.instance, this.profile);\n    return this;\n  }\n\n  async selectProfile(instance, profile) {\n    const stack = instance.exports.stackSave();\n\n    const cProfiles = allocateStringOnStack(instance, JSON.stringify({ profile }));\n    const cProfile = allocateStringOnStack(instance, 'profile');\n\n    const opt = instance.exports.quiet_decoder_profile_str(cProfiles, cProfile);\n    this.decoder = instance.exports.quiet_decoder_create(opt, this.sampleRate);\n    instance.exports.free(opt);\n\n    instance.exports.stackRestore(stack);\n    this.samples = mallocArray(sampleBufferSize, this.instance);\n    this.frame = instance.exports.malloc(sampleBufferSize);\n\n    return this;\n  }\n\n  process(inputs, outputs) {\n    if (!inputs[0].length) {\n      return true;\n    }\n    const input = inputs[0];\n    const output = outputs[0][0];\n\n    this.inputRingBuffer.push([...input]);\n\n    if (this.inputRingBuffer.framesAvailable >= sampleBufferSize) {\n      this.inputRingBuffer.pull([this.samples.view]);\n\n      this.bufferIndex = 0;\n      this.instance.exports.quiet_decoder_consume(\n        this.decoder, this.samples.pointer, sampleBufferSize,\n      );\n\n      const read = this.instance.exports.quiet_decoder_recv(\n        this.decoder, this.frame, sampleBufferSize,\n      );\n\n      if (read !== -1) {\n        const HEAPU8 = new Int8Array(this.instance.exports.memory.buffer);\n\n        const slice = HEAPU8.slice(this.frame, this.frame + read);\n        const value = decode(slice.buffer);\n        this.port.postMessage({\n          type: 'payload',\n          value,\n        });\n      }\n    }\n\n    output.forEach((channel) => {\n      for (let i = 0; i < channel.length; i += 1) {\n        channel[i] = 1;\n      }\n    });\n\n    return true;\n  }\n}\n\nregisterProcessor('quiet-processor-node', WhiteNoiseProcessor);\n"],"names":["$68377fe9d3c3a31e814504f68141f3d3$var$allocateStringOnStack","instance","string","arr","ret","exports","stackAlloc","length","Int8Array","memory","buffer","set","$68377fe9d3c3a31e814504f68141f3d3$var$allocateArrayOnStack","split","map","x","charCodeAt","$68377fe9d3c3a31e814504f68141f3d3$var$RingBuffer","[object Object]","channelCount","_readIndex","_writeIndex","_framesAvailable","_channelCount","_length","_channelData","i","this","Float32Array","framesAvailable","arraySequence","sourceLength","i1","writeIndex","channel","destinationLength","readIndex","$68377fe9d3c3a31e814504f68141f3d3$var$importObject","env","__sys_getpid","wasi_snapshot_preview1","proc_exit","clock_time_get","fd_close","fd_write","fd_seek","fd_read","$68377fe9d3c3a31e814504f68141f3d3$var$sampleBufferSize","$68377fe9d3c3a31e814504f68141f3d3$var$WhiteNoiseProcessor","AudioWorkletProcessor","options","super","quietWasmBytes","profile","profile1","sampleRate","processorOptions","inputRingBuffer","init","WebAssembly","instantiate","selectProfile","stack","stackSave","cProfiles","JSON","stringify","cProfile","opt","quiet_decoder_profile_str","decoder","quiet_decoder_create","free","stackRestore","samples","bufferSize","pointer","malloc","subarray","$68377fe9d3c3a31e814504f68141f3d3$var$mallocArray","frame","inputs","outputs","input","output","push","pull","view","bufferIndex","quiet_decoder_consume","read","quiet_decoder_recv","slice","value","buf","Uint8Array","String","fromCharCode","join","port","postMessage","type","forEach","registerProcessor"],"version":3,"file":"quiet.worklet.dd17454f.js.map"}